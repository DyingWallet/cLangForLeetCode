//力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。
//小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：
//U : 向y轴正方向移动一格
//R : 向x轴正方向移动一格。
//不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。
//给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。
//示例 1：
//输入：command = "URR", obstacles = [], x = 3, y = 2
//输出：true
//解释：U(0, 1)->R(1, 1)->R(2, 1)->U(2, 2)->R(3, 2)。
//示例 2：
//输入：command = "URR", obstacles = [[2, 2]], x = 3, y = 2
//输出：false
//解释：机器人在到达终点前会碰到(2, 2)的障碍物。
//示例 3：
//输入：command = "URR", obstacles = [[4, 2]], x = 3, y = 2
//输出：true
//解释：到达终点后，再碰到障碍物也不影响返回结果。
//限制：
//2 <= command的长度 <= 1000
//command由U，R构成，且至少有一个U，至少有一个R
//0 <= x <= 1e9, 0 <= y <= 1e9
//0 <= obstacles的长度 <= 1000
//obstacles[i]不为原点或者终点

#include"leetCode.h"

bool canReach(char* command, int** obstacles, int obstaclesSize, int* obstaclesColSize, int x, int y, int curX, int curY,int cmd);
bool isTraped(int** obs, int obsRowSize, int* obsColSize, int curX, int curY);
static int cmdLen = 0;
bool robot(char* command, int** obstacles, int obstaclesSize, int* obstaclesColSize, int x, int y) {
	cmdLen = strlen(command);
	if (cmdLen < 2 || cmdLen > 1000) return false;
	return canReach(command,obstacles,obstaclesSize,obstaclesColSize,x,y,0,0,0);
}

bool canReach(char* command, int** obs, int obsRowSize, int* obsColSize, int x, int y, int curX, int curY, int cmd) {
	if (curX == x && curY == y) return true;
	if (curX > 1e9 || curY > 1e9) return false;
	if (isTraped(obs,obsRowSize,obsColSize,curX,curY)) return false;	//检查是否是障碍物
	if (cmd > cmdLen) cmd = 0;
	if (command[cmd] == 'U')
		return canReach(command, obs, obsRowSize, obsColSize, x, y + 1, curX, curY, cmd++);
	if (command[cmd] == 'R')
		return canReach(command, obs, obsRowSize, obsColSize, x + 1, y, curX, curY, cmd++);
	return false;
}

bool isTraped(int** obs, int obsSize, int* obsColSize, int curX, int curY) {
	int* temp = NULL;
	for (int i = 0; i < obsSize; i++) {
		temp = obs[i];
		if (temp[0] == curX && temp[1] == curY) return true;
	}
	return false;
}